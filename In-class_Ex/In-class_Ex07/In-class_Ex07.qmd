---
title: "In-Class Exercise 7 - Geographical Segmentation with Spatially Constrained Clustering Techniques"
format:
  html:
    code-fold: true
    code-summary: "Show the code"

execute: 
  eval: true
  echo: true
  warning: false
  freeze: true

date: "`r Sys.Date()`"
---

## 1.0 Getting started

### 1.1 Load libraries

```{r}
pacman::p_load( spdep, sp, tmap, sf, ClustGeo, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

### 1.2 data import and preparation

```{r}
shan_sf <- st_read(dsn = "data/geospatial", 
                   layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) %>%
  select(c(2:7))
```

::: callout-note filter is from dplyr package in tidyverse. It is used to filter rows that meet a certain condition. In this case, we are filtering the rows that meet the condition of ST being either "Shan (East)", "Shan (North)", or "Shan (South)". 

```{r}
shan_sf
```
::: callout-note gives you a description and view of your data. class(df) is used to check the class of the data. sf, data.frame 

```{r}
ict <- read_csv ("data/aspatial/Shan-ICT.csv")
```

```{r}
summary(ict)
```
::: callout-note summary gives you a summary statistics of each column in the df 


```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

In the above code, we scaled the data by dividing the number of each ICT indicator by the total number of households in each township and then multiplied by 1000 to get the number of ICT indicators per 1000 households. We then renamed the columns to make them more readable.

::: callout-note mutate is a function from the dplyr package in the tidyverse. It is used to add new columns to the data frame. rename is also a function from the dplyr package in the tidyverse. It is used to rename columns in the data frame. 


```{r}
summary(ict_derived)
```

# 2.0 EDA

## 2.1 EDA using satistical graphics

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```

## 2.2 EDA using choropleth maps

```{r}
shan_sf <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
```

write rds 

```{r}
write_rds(shan_sf, "data/rds/shan_sf.rds")
```

```{r}
```



```{r}
shan_sf <- read_rds("data/rds/shan_sf.rds")
```

```{r}
qtm(shan_sf, "RADIO_PR")
```

```{r}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf) + 
  tm_fill(col = "TT_HOUSEHOLDS",
          n = 5,
          style = "jenks", 
          title = "Total households") + 
  tm_borders(alpha = 0.5) 

RADIO.map <- tm_shape(shan_sf) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Number Radio ") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)
```

```{r}
tm_shape(shan_sf) +
    tm_polygons(c("TT_HOUSEHOLDS", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
  tm_legend(legend.position = c("right", "bottom"))+
  tm_layout(outer.margins=0, asp=0)
```

# 3.0 correlation analysis

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")

```

::: callout-note cor is a function from the base R package. It is used to compute the correlation between variables in a data frame. corrplot.mixed is a function from the corrplot package. It is used to create a correlation plot. 

similar to the scatterplot, corplot gives a better visual. 

# 4.0 hierachy cluster analysis


##### 4.0.1 Data prep for cluster analysis 

Remove the geometry column as the package used for clustering does not support spatial data

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

instead of using the row number as the row name, we can use the township name as the row name

```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars,10)
```

::: callout-note row.names is a function from the base R package. It is used to set the row names of a data frame. 


```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

write rds 

```{r}
write_rds(shan_ict, "data/rds/shan_ict.rds")
```

```{r}
shan_ict <- read_rds("data/rds/shan_ict.rds")
```

Data standardisation

min-max standard

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

z score standard

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```

visualize

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

Raw values are not standardised, while the other two are standardised. Raw values is rather skewed to the right, while the other two are more normally distributed.

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

## 4.1 computing proximity matrix

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

::: callout-note dist is a function from the base R package. It is used to compute the distance between observations in a data frame. More information can be found in rdocumentation.org. manhattan = city block, minkowski = chebychev 

```{r}
proxmat
```

## 4.2 Computing hierarchical clustering

```{r}

hclust_ward <- hclust(proxmat, method = 'ward.D')
```

::: callout-note hclust is a function from the base R package. It is used to compute hierarchical clustering. More information can be found in rdocumentation.org.


```{r fig.width=10, fig.height=6}
plot(hclust_ward, cex = 0.6)
```

The dendrogram shows the different clusters and at which height they are merged. Depending on the height at which the clusters are merged, we can determine the number of clusters.

::: callout-note we indicate the figure size using fig.width and fig.height. this lets us control and adjust the size of our output. 

## 4.3 select optial clustering algo

```{r}
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

ac <- function(x) {
  agnes(shan_ict, method = x)$ac
}

map_dbl(m, ac)
```

With reference to the output above, we can see that Ward’s method provides the strongest clustering structure among the four methods assessed. Hence, in the subsequent analysis, only Ward’s method will be used.

## 5 determining cluster

There are three commonly used methods to determine the optimal clusters, they are:

Elbow Method Average Silhouette Method Gap Statistic Method

## 5.1 gap statistic

```{r}
set.seed(12345)
gap_stat <- clusGap(shan_ict, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")
```

```{r}
fviz_gap_stat(gap_stat)
```

In the dendrogram displayed above, each leaf corresponds to one observation. As we move up the tree, observations that are similar to each other are combined into branches, which are themselves fused at a higher height.

The height of the fusion, provided on the vertical axis, indicates the (dis)similarity between two observations. The higher the height of the fusion, the less similar the observations are. Note that, conclusions about the proximity of two observations can be drawn only based on the height where branches containing those two observations first are fused. We cannot use the proximity of two observations along the horizontal axis as a criteria of their similarity.

It’s also possible to draw the dendrogram with a border around the selected clusters by using rect.hclust() of R stats. The argument border is used to specify the border colors for the rectangles.

::: callout-note IMPORTANT! local optimisation might be present. optimised point should be around 5 or 6 

interpreting the dendrograms

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 6, 
            border = 2:5)
```

::: callout-note k=6 determines the number of clusters. 

Visually-driven hierarchical clustering analysis

```{r}
shan_ict_mat <- data.matrix(shan_ict)
```

```{r}
heatmaply(normalize(shan_ict_mat),
          Colv=NA,
          dist_method = "euclidean",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors = Blues,
          k_row = 6,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="Geographic Segmentation of Shan State by ICT indicators",
          xlab = "ICT Indicators",
          ylab = "Townships of Shan State"
          )
```

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```

```{r}
qtm(shan_sf_cluster, "CLUSTER")
```

# 6.0 spatially constrained clustering: skater approach

convert data into spatialpolygondataframe

```{r}
# shan_sp <- as_Spatial(shan_sf)
```

We can remove converting to SP as the latest version of spdep allows for sf objects. 

```{r}
shan.nb <- poly2nb(shan_sf)
summary(shan.nb)
```

Computing minimum spanning tree

```{r}
lcosts <- nbcosts(shan.nb, shan_ict)
```

```{r}
shan.w <- nb2listw(shan.nb, 
                   lcosts, 
                   style="B")
summary(shan.w)
```

```{r}
shan.mst <- mstree(shan.w)
```

```{r}
class(shan.mst)
```

```{r}
dim(shan.mst)
```

```{r}
head(shan.mst)
```

## 6.1 Computing spatially constrained clusters using SKATER method

```{r}
clust6 <- spdep::skater(edges = shan.mst[,1:2], 
                 data = shan_ict, 
                 method = "euclidean", 
                 ncuts = 5)
```

```{r}
str(clust6)
```

```{r}
ccs6 <- clust6$groups
ccs6
```

```{r}
table(ccs6)
```

```{r}
plot(st_geometry(shan_sf), border=gray(.5)) 
pts <- st_coordinates(st_centroid(shan_sf))
plot(shan.nb, 
     pts, 
     col="blue", 
     add=TRUE)
```

include st_geometry to plot only the geometry column. pts can be reused throughout the document. 


plot(clust6, coordinates(shan_sp), cex.lab=.7, groups.colors=c("red","green","blue", "brown", "pink"), cex.circles=0.005, add=TRUE)

```{r}
groups_mat <- as.matrix(clust6$groups)
shan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%
  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)
qtm(shan_sf_spatialcluster, "SP_CLUSTER")
```

```{r}
hclust.map <- qtm(shan_sf_cluster,
                  "CLUSTER") + 
  tm_borders(alpha = 0.5) 

shclust.map <- qtm(shan_sf_spatialcluster,
                   "SP_CLUSTER") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(hclust.map, shclust.map,
             asp=NA, ncol=2)
```

# 7.0 Spatially Constrained Clustering: ClustGeo Method

## 7.1 Ward-like hierarchical clustering: ClustGeo

```{r}
nongeo_cluster <- hclustgeo(proxmat)
plot(nongeo_cluster, cex = 0.5)
rect.hclust(nongeo_cluster, 
            k = 6, 
            border = 2:5)
```

```{r}
groups <- as.factor(cutree(nongeo_cluster, k=6))
```

numeric to factor. 

```{r}
shan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

```{r}
qtm(shan_sf_ngeo_cluster, "CLUSTER")
```

## 7.2 Spatially Constrained Hierarchical Clustering

```{r}
dist <- st_distance(shan_sf, shan_sf)
distmat <- as.dist(dist)

```

```{r}
cr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)
```

```{r}
clustG <- hclustgeo(proxmat, distmat, alpha = 0.3)
```

```{r}
groups <- as.factor(cutree(clustG, k=6))
```

```{r}
shan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

left join must have a unique identifier. therefore we use cbind to join the two dataframes as the columns are the same 

```{r}
qtm(shan_sf_Gcluster, "CLUSTER")
```

# 8.0 Visual Interpretation of Clusters

## 8.1 Visualising individual clustering variable

```{r}
ggplot(data = shan_sf_ngeo_cluster,
       aes(x = CLUSTER, y = RADIO_PR)) +
  geom_boxplot()
```

## 8.2 Multivariate Visualisation

```{r}
ggparcoord(data = shan_sf_ngeo_cluster, 
           columns = c(17:21), 
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of ICT Variables by Cluster") +
  facet_grid(~ CLUSTER) + 
  theme(axis.text.x = element_text(angle = 30))
```

Gives more description of the clusters. in this case, cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in cluster 5 tends to own the lowest of all the ICT indicators.

```{r}
shan_sf_ngeo_cluster %>% 
  st_set_geometry(NULL) %>%
  group_by(CLUSTER) %>%
  summarise(mean_RADIO_PR = mean(RADIO_PR),
            mean_TV_PR = mean(TV_PR),
            mean_LLPHONE_PR = mean(LLPHONE_PR),
            mean_MPHONE_PR = mean(MPHONE_PR),
            mean_COMPUTER_PR = mean(COMPUTER_PR))
```
