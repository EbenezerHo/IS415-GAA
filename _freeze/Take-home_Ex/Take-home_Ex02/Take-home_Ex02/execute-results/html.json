{
  "hash": "ba9cc413c2a79d765b2761410175df38",
  "result": {
    "markdown": "---\ntitle: \"Take-home Exercise 02\"\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show the code\"\n\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\ndate: \"2024-03-02\"\n---\n\n\n# Take Home Exercise 2: Application of Spatial and Spatio-temporal Analysis Methods to Discover the Distribution of Dengue Fever in Tainan City, Taiwan\n\n## Setting the scene\n\nDengue Hemorrhagic Fever (in short dengue fever) is one of the most widespread mosquito-borne diseases in the most tropical and subtropical regions. It is an acute disease caused by dengue virus infection which is transmitted by female Aedes aegypti and Aedes albopictus mosquitoes. In 2015, Taiwan had recorded the most severe dengue fever outbreak with more than 43,000 dengue cases and 228 deaths. Since then, the annual reported dengue fever cases were maintained at the level of not more than 200 cases. However, in 2023, Taiwan recorded 26703 dengue fever cases. Figure below reveals that more than 25,000 cases were reported at Tainan City.\n\n## Objectives\n\nAs a curious geospatial analytics green horn, you are interested to discover:\n\nif the distribution of dengue fever outbreak at Tainan City, Taiwan are independent from space and space and time. If the outbreak is indeed spatial and spatio-temporal dependent, then, you would like to detect where are the clusters and outliers, and the emerging hot spot/cold spot areas.\n\n## The Task\n\nThe specific tasks of this take-home exercise are as follows:\n\n-   Using appropriate function of sf and tidyverse, preparing the following geospatial data layer:\n\n    -   a study area layer in sf polygon features. It must be at village level and confined to the D01, D02, D04, D06, D07, D08, D32 and D39 counties of Tainan City, Taiwan.\n\n    -   a dengue fever layer within the study area in sf point features. The dengue fever cases should be confined to epidemiology week 31-50, 2023.\n\n    -   a derived dengue fever layer in spacetime s3 class of sfdep. It should contain, among many other useful information,\n\n    -   a data field showing number of dengue fever cases by village and by epidemiology week.\n\n-   Using the extracted data, perform global spatial autocorrelation analysis by using sfdep methods.\n\n-   Using the extracted data, perform local spatial autocorrelation analysis by using sfdep methods.\n\n-   Using the extracted data, perform emerging hotspot analysis by using sfdep methods.\n\n-   Describe the spatial patterns revealed by the analysis above.\n\n## Install packages and load libraries\n\nPackages Used:\n\n-   [sf](https://cran.r-project.org/web/packages/sf/): For importing, managing, and processing geospatial data.\n\n-   [tidyverse](https://www.tidyverse.org/): Collection of packages for data science tasks.\n\n-   [tmap](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html): For creating thematic maps, such as choropleth and bubble maps.\n\n-   [sfdep](https://sfdep.josiahparry.com/): Creating an sf and tidyverse friendly interface.\n\n-   [Kendall](https://cran.r-project.org/web/packages/Kendall/index.html): To perform Mann Kendall test on Gi\\*\n\n-   [lubridate](https://lubridate.tidyverse.org/): For working with dates and times.\n\n-   [dplyr](https://dplyr.tidyverse.org/): For data manipulation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tmap, tidyverse, lubridate, dplyr, sfdep, Kendall)\n```\n:::\n\n\n## 1. Load the data\n\n### 1.1 Importing, Processing & Cleaning the Data\n\nWe begin first by working with dengue (Aspatial) data as aspatial data usually requires more wrangling.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue <- read_csv(\"data/aspatial/Dengue_Daily.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dengue)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(dengue)\n```\n:::\n\n\nFrom viewing the head of dengue, we can see that the data contains \"None\" values in x and y coordinates. We'll remove them using the filter function from dplyr.\n\n![](images/none_value.jpg)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue <- dengue %>% filter(最小統計區中心點X != \"None\" | 最小統計區中心點Y != \"None\")\n```\n:::\n\n\nSince the task confines us to the epidemiology week 31-50, 2023, we'll filter the data to only include the specified weeks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue <- dengue %>% filter(year(發病日) == 2023) %>% filter(epiweek(發病日) >=31 & epiweek(發病日)<= 50)\n```\n:::\n\n\nFrom there, we'll filter the columns to select what we'll be using later on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- dengue %>%\n  select(\"發病日\", \"最小統計區中心點X\", \"最小統計區中心點Y\")\n```\n:::\n\n\nRename the columns to english to make it easier to read. We'll use [names()](https://stackoverflow.com/questions/46014332/using-mutate-in-r-to-rename-items-in-a-column) from base R to rename the columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(df) <- c(\"onset-date\", \"x-coordinate\",\"y-coordinate\")\n```\n:::\n\n\nOnce we are satisfied with our aspatial data, let's import our geospatial data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntainan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"TAINAN_VILLAGE\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(tainan)\n```\n:::\n\n\nSince we'll need to combine the dengue data with the tainan data, we'll need to ensure that the coordinate reference system (CRS) of both datasets are the same. We'll use [st_crs()](https://r-spatial.github.io/sf/reference/st_crs.html) to check the CRS of the tainan data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(tainan)\n```\n:::\n\n\nCheck if there are any invalid values in the tainan data using [st_is_valid()](https://r-spatial.github.io/sf/reference/st_is_valid.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(which(st_is_valid(tainan) == FALSE))\n```\n:::\n\n\nOnce it's done, we'll convert our aspatial dataset into a spatial dataset using [st_as_sf()](https://r-spatial.github.io/sf/reference/st_as_sf.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_sf <- st_as_sf(df, \n                      coords = c(\"x-coordinate\",\"y-coordinate\"),\n                      crs = 3824)\n```\n:::\n\n\nWe are also confining our tainan data set to the specified villages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvillages <- c(\"D01\", \"D02\", \"D04\", \"D06\", \"D07\", \"D08\", \"D32\", \"D39\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntainan_vil <- tainan %>%\n  filter(TOWNID %in% villages)\n```\n:::\n\n\nOnce that is done, let's combine the datasets together and see the dengue cases for the specified villages. We'll use [st_join()](https://r-spatial.github.io/sf/reference/st_join.html) to join the datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselected_dengue <- dengue_sf %>% st_join(tainan_vil, join = st_within)\n```\n:::\n\n\nRemove rows where TOWNID is NA\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselected_dengue <- selected_dengue %>% filter(!is.na(TOWNID))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noverall_dengue <- st_intersection(dengue_sf, tainan_vil)\n```\n:::\n\n\nOnce we are satisfied with our data wrangling, we'll save the datasets into rds files for future use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(overall_dengue, \"data/rds/overall_dengue.rds\")\nsaveRDS(tainan_vil, \"data/rds/tainan_vil.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noverall_dengue <- readRDS(\"data/rds/overall_dengue.rds\")\ntainan_vil <- readRDS(\"data/rds/tainan_vil.rds\")\n```\n:::\n\n\n## 2. Visualizing the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(tainan_vil), col = \"grey\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(overall_dengue), col = \"grey\")\nplot(st_geometry(tainan_vil), add = TRUE)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nFrom here, we can identify the rough distribution of dengue cases in tainan. We notice that majority of the cases are occuring in the middle segments of tainan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_sf <- st_join(tainan_vil, overall_dengue, join = st_contains)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_sf <- dengue_sf %>% select(VILLENG.x, TOWNID.x, onset.date, geometry,week) %>% rename(VILLENG = VILLENG.x) %>% rename(TOWNID = TOWNID.x) %>% rename(onset_date = onset.date)\n```\n:::\n\n\nwe'll attempt to group by both villeng and townid first then villeng by itself. This section will be explained later on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_agg <- st_join(tainan_vil, dengue_sf, join = st_contains) %>% group_by (VILLENG.x, TOWNID.x) %>% summarize(total_cases= n())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_agg2 <- st_join(tainan_vil, dengue_sf, join = st_contains) %>% group_by (VILLENG.x) %>% summarize(total_cases= n())\n```\n:::\n\n\nLet's save our results for future work.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(dengue_agg, \"data/rds/dengue_agg.rds\")\nsaveRDS(dengue_agg2, \"data/rds/dengue_agg2.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_agg <- readRDS(\"data/rds/dengue_agg.rds\")\ndengue_agg2 <- readRDS(\"data/rds/dengue_agg2.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(dengue_agg2) + \n  tm_polygons(\"total_cases\") + \n  tm_layout(main.title = \"Number of dengue cases by Village\", \n            main.title.position = \"center\",\n            main.title.size = 1.0,\n            legend.height = 0.45,\n            legend.width=0.35,\n            frame = TRUE) + \n  tm_borders(alpha=0.5)+\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nGrouping VillEng by itself, we can identify a few spots where dengue cases are more prevalent.\n\nWe will then plot a bar chart to show the distribution of dengue cases in each village.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dengue_agg, aes(x = TOWNID.x, y = total_cases)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +\n  labs(title = \"Dengue cases in Tainan\",\n       x = \"Village\",\n       y = \"Number of cases\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nFrom the chart above, we can notice that village D07, D08 and D32 have the lowest number of dengue cases. Meanwhile, D06 and D39 has the highest.\n\n## 3. Global Spatial Autocorrelation Analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_agg_sf <- dengue_agg %>% select(VILLENG.x, total_cases, geometry) %>% rename(VILLENG = VILLENG.x)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_count <- dengue_agg_sf\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_count\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 258 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 120.0627 ymin: 22.89401 xmax: 120.2925 ymax: 23.09144\nGeodetic CRS:  TWD97\n# A tibble: 258 × 3\n# Groups:   VILLENG [249]\n   VILLENG     total_cases                                              geometry\n   <chr>             <int>                                         <POLYGON [°]>\n 1 Andong Vil.          67 ((120.2164 23.0404, 120.2154 23.04033, 120.2153 23.0…\n 2 Anfu Vil.           311 ((120.1932 23.0294, 120.1929 23.02938, 120.1926 23.0…\n 3 Anhe Vil.            73 ((120.2258 23.04424, 120.2219 23.03862, 120.2219 23.…\n 4 Ankang Vil.          97 ((120.2269 23.01413, 120.2274 23.01331, 120.2277 23.…\n 5 Anqing Vil.         111 ((120.2113 23.04414, 120.2111 23.04413, 120.2108 23.…\n 6 Anshun Vil.          34 ((120.2136 23.05601, 120.2136 23.05586, 120.2135 23.…\n 7 Anxi Vil.           110 ((120.2123 23.03689, 120.212 23.03685, 120.2121 23.0…\n 8 Bao'an Vil.          19 ((120.2304 22.93544, 120.2301 22.93511, 120.2301 22.…\n 9 Beihua Vil.          82 ((120.2034 23.00257, 120.2032 23.0022, 120.2028 23.0…\n10 Beimen Vil.         249 ((120.2176 23.02032, 120.2173 23.02013, 120.2172 23.…\n# ℹ 248 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(dengue_count$VILLENG)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] \"Andong Vil.\"     \"Anfu Vil.\"       \"Anhe Vil.\"       \"Ankang Vil.\"    \n  [5] \"Anqing Vil.\"     \"Anshun Vil.\"     \"Anxi Vil.\"       \"Bao'an Vil.\"    \n  [9] \"Beihua Vil.\"     \"Beimen Vil.\"     \"Beiwan Vil.\"     \"Beixing Vil.\"   \n [13] \"Budai Vil.\"      \"Chang'an Vil.\"   \"Chengbei Vil.\"   \"Chengda Vil.\"   \n [17] \"Chengde Vil.\"    \"Chengdong Vil.\"  \"Chenggong Vil.\"  \"Chenghuang Vil.\"\n [21] \"Chengnan Vil.\"   \"Chengxi Vil.\"    \"Chengzhong Vil.\" \"Chihkan Vil.\"   \n [25] \"Chongcheng Vil.\" \"Chongde Vil.\"    \"Chonghui Vil.\"   \"Chongming Vil.\" \n [29] \"Chongshan Vil.\"  \"Chongwen Vil.\"   \"Chongxin Vil.\"   \"Chongxue Vil.\"  \n [33] \"Da'an Vil.\"      \"Da'en Vil.\"      \"Dacheng Vil.\"    \"Dade Vil.\"      \n [37] \"Dafeng Vil.\"     \"Dafu Vil.\"       \"Dagang Vil.\"     \"Daguang Vil.\"   \n [41] \"Dahe Vil.\"       \"Dajia Vil.\"      \"Daliang Vil.\"    \"Dalin Vil.\"     \n [45] \"Daqiao Vil.\"     \"Datong Vil.\"     \"Dawan Vil.\"      \"Daxing Vil.\"    \n [49] \"Daxue Vil.\"      \"Dazhi Vil.\"      \"Dazhong Vil.\"    \"Degao Vil.\"     \n [53] \"Deguang Vil.\"    \"Diandong Vil.\"   \"Dianxi Vil.\"     \"Ding'an Vil.\"   \n [57] \"Dong'an Vil.\"    \"Dongguang Vil.\"  \"Donghe Vil.\"     \"Dongmen Vil.\"   \n [61] \"Dongming Vil.\"   \"Dongqiao Vil.\"   \"Dongsheng Vil.\"  \"Dongwan Vil.\"   \n [65] \"Dongxing Vil.\"   \"Dongzhi Vil.\"    \"Duiyue Vil.\"     \"Erwang Vil.\"    \n [69] \"Erxing Vil.\"     \"Fahua Vil.\"      \"Fenghuang Vil.\"  \"Fotan Vil.\"     \n [73] \"Fude Vil.\"       \"Fuguo Vil.\"      \"Fuhua Vil.\"      \"Funan Vil.\"     \n [77] \"Fuqian Vil.\"     \"Fuqiang Vil.\"    \"Fuxing Vil.\"     \"Fuyu Vil.\"      \n [81] \"Gongqin Vil.\"    \"Gongwen Vil.\"    \"Gongyuan Vil.\"   \"Guangfu Vil.\"   \n [85] \"Guangming Vil.\"  \"Guangxian Vil.\"  \"Guangzhou Vil.\"  \"Guansheng Vil.\" \n [89] \"Guo'an Vil.\"     \"Guoping Vil.\"    \"Guozhai Vil.\"    \"Haidian Vil.\"   \n [93] \"Haidong Vil.\"    \"Hainan Vil.\"     \"Haixi Vil.\"      \"Heping Vil.\"    \n [97] \"Heshun Vil.\"     \"Hexing Vil.\"     \"Houbi Vil.\"      \"Houjia Vil.\"    \n[101] \"Huade Vil.\"      \"Huaping Vil.\"    \"Huwei Vil.\"      \"Jiading Vil.\"   \n[105] \"Jianguo Vil.\"    \"Jiannan Vil.\"    \"Jianping Vil.\"   \"Jincheng Vil.\"  \n[109] \"Jinhua Vil.\"     \"Junnan Vil.\"     \"Junwang Vil.\"    \"Kainan Vil.\"    \n[113] \"Kaishan Vil.\"    \"Kaiyuan Vil.\"    \"Kunshan Vil.\"    \"Kunshen Vil.\"   \n[117] \"Liren Vil.\"      \"Liuhe Vil.\"      \"Lixiang Vil.\"    \"Lixing Vil.\"    \n[121] \"Longpu Vil.\"     \"Longshan Vil.\"   \"Longtan Vil.\"    \"Lu'er Vil.\"     \n[125] \"Ludong Vil.\"     \"Meihua Vil.\"     \"Mingde Vil.\"     \"Mingliang Vil.\" \n[129] \"Mingxing Vil.\"   \"Nanchang Vil.\"   \"Nandou Vil.\"     \"Nanhua Vil.\"    \n[133] \"Nanmei Vil.\"     \"Nanmen Vil.\"     \"Nansheng Vil.\"   \"Nanwan Vil.\"    \n[137] \"Nanxing Vil.\"    \"Niaosong Vil.\"   \"Ping'an Vil.\"    \"Pingtong Vil.\"  \n[141] \"Puyuan Vil.\"     \"Qiancao Vil.\"    \"Qingcao Vil.\"    \"Quannan Vil.\"   \n[145] \"Ren'ai Vil.\"     \"Rende Vil.\"      \"Renhe Vil.\"      \"Renyi Vil.\"     \n[149] \"Sanhe Vil.\"      \"Sanmin Vil.\"     \"Shalun Vil.\"     \"Shangding Vil.\" \n[153] \"Shanglun Vil.\"   \"Shenggong Vil.\"  \"Shengli Vil.\"    \"Shenzhou Vil.\"  \n[157] \"Shuang'an Vil.\"  \"Sicao Vil.\"      \"Song'an Vil.\"    \"Taizi Vil.\"     \n[161] \"Tianfei Vil.\"    \"Tianliao Vil.\"   \"Tong'an Vil.\"    \"Tuku Vil.\"      \n[165] \"Wangcheng Vil.\"  \"Wangliao Vil.\"   \"Wangxing Vil.\"   \"Weiguo Vil.\"    \n[169] \"Weixia Vil.\"     \"Wencheng Vil.\"   \"Wenhua Vil.\"     \"Wennan Vil.\"    \n[173] \"Wenping Vil.\"    \"Wensheng Vil.\"   \"Wenxian Vil.\"    \"Wenyuan Vil.\"   \n[177] \"Wutiaogang Vil.\" \"Wuwang Vil.\"     \"Wuzhu Vil.\"      \"Xianbei Vil.\"   \n[181] \"Xiangong Vil.\"   \"Xiaobei Vil.\"    \"Xiaodong Vil.\"   \"Xiaoximen Vil.\" \n[185] \"Xibei Vil.\"      \"Xiding Vil.\"     \"Xidong Vil.\"     \"Xihe Vil.\"      \n[189] \"Xihu Vil.\"       \"Xinan Vil.\"      \"Xinchang Vil.\"   \"Xindong Vil.\"   \n[193] \"Xingfu Vil.\"     \"Xingnong Vil.\"   \"Xinsheng Vil.\"   \"Xinshu Vil.\"    \n[197] \"Xinshun Vil.\"    \"Xintian Vil.\"    \"Xinxing Vil.\"    \"Xiqi Vil.\"      \n[201] \"Xiqiao Vil.\"     \"Xishi Vil.\"      \"Xiwan Vil.\"      \"Xixian Vil.\"    \n[205] \"Xixin Vil.\"      \"Xuedong Vil.\"    \"Yancheng Vil.\"   \"Yantian  Vil.\"  \n[209] \"Yanxing  Vil.\"   \"Yanxing Vil.\"    \"Yanzhou  Vil.\"   \"Yaowang Vil.\"   \n[213] \"Yijia Vil.\"      \"Yiping Vil.\"     \"Yizai Vil.\"      \"Yonghua Vil.\"   \n[217] \"Yongkang Vil.\"   \"Yongming Vil.\"   \"Yongning Vil.\"   \"Yongxiang Vil.\" \n[221] \"Yuanbao Vil.\"    \"Yuandian Vil.\"   \"Yuandong Vil.\"   \"Yuanmei Vil.\"   \n[225] \"Yuanxi Vil.\"     \"Yuanzhong Vil.\"  \"Yuguang Vil.\"    \"Yunong Vil.\"    \n[229] \"Yuping Vil.\"     \"Yusheng Vil.\"    \"Zaixing Vil.\"    \"Zhangnan Vil.\"  \n[233] \"Zhangsheng Vil.\" \"Zhangxing Vil.\"  \"Zhengjue Vil.\"   \"Zhengqiang Vil.\"\n[237] \"Zhenxing Vil.\"   \"Zhonghua Vil.\"   \"Zhonglou Vil.\"   \"Zhongxi Vil.\"   \n[241] \"Zhongxiao Vil.\"  \"Zhongxing Vil.\"  \"Zhongzhou Vil.\"  \"Zhoubei Vil.\"   \n[245] \"Zhounan Vil.\"    \"Zhuangjing Vil.\" \"Zhuxi Vil.\"      \"Ziqiang Vil.\"   \n[249] \"Zongtou Vil.\"   \n```\n:::\n:::\n\n\nWhen viewing the unique values of villeng, we notice that there are duplicates in the dataset. We use the function cat() to print the number of unique villages, total features, and any duplicate values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count the number of unique values in the VILLENG column\nnum_unique_villages <- length(unique(dengue_count$VILLENG))\n\n# Count the total number of features (polygons) in the dataset\ntotal_features <- nrow(dengue_count)\n\n# Check for duplicate values in the VILLENG column\nduplicate_villages <- dengue_count %>%\n  group_by(VILLENG) %>%\n  filter(n() > 1) %>%\n  distinct()\n\n# Print the number of unique villages, total features, and any duplicate values\ncat(\"Number of unique villages:\", num_unique_villages, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of unique villages: 249 \n```\n:::\n\n```{.r .cell-code}\ncat(\"Total features (polygons):\", total_features, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal features (polygons): 258 \n```\n:::\n\n```{.r .cell-code}\ncat(\"Duplicate villages:\", nrow(duplicate_villages), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDuplicate villages: 17 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nduplicate_villages \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 17 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 120.1705 ymin: 22.9264 xmax: 120.2458 ymax: 23.07585\nGeodetic CRS:  TWD97\n# A tibble: 17 × 3\n# Groups:   VILLENG [8]\n   VILLENG        total_cases                                           geometry\n   <chr>                <int>                                      <POLYGON [°]>\n 1 Chenggong Vil.          84 ((120.2094 23.02295, 120.2088 23.02294, 120.2081 …\n 2 Chenggong Vil.          62 ((120.2247 22.96165, 120.2247 22.96165, 120.2246 …\n 3 Chenggong Vil.          32 ((120.2388 23.00454, 120.2388 23.00452, 120.2385 …\n 4 Fuxing Vil.            139 ((120.2373 22.98504, 120.237 22.98501, 120.2361 2…\n 5 Fuxing Vil.             61 ((120.2433 23.00544, 120.2432 23.00544, 120.2427 …\n 6 Ren'ai Vil.             78 ((120.2248 23.0057, 120.2243 23.00504, 120.2242 2…\n 7 Ren'ai Vil.             17 ((120.2214 22.96205, 120.2213 22.96203, 120.2211 …\n 8 Renhe Vil.             103 ((120.2361 22.96897, 120.2367 22.969, 120.2371 22…\n 9 Renhe Vil.               9 ((120.2233 22.96183, 120.2233 22.96183, 120.2233 …\n10 Wennan Vil.             81 ((120.1866 22.98634, 120.1865 22.98631, 120.1862 …\n11 Wennan Vil.             18 ((120.2226 23.07585, 120.2225 23.07582, 120.2225 …\n12 Xibei Vil.              17 ((120.1706 22.95257, 120.1706 22.95249, 120.1706 …\n13 Xibei Vil.              91 ((120.214 23.02902, 120.2135 23.02874, 120.2132 2…\n14 Xidong Vil.             21 ((120.2015 22.95139, 120.1987 22.95137, 120.1983 …\n15 Xidong Vil.            167 ((120.1987 23.029, 120.1987 23.02896, 120.1988 23…\n16 Zhongxing Vil.          26 ((120.2262 23.00712, 120.2261 23.006, 120.2258 23…\n17 Zhongxing Vil.          51 ((120.2417 23.00886, 120.2416 23.00883, 120.2416 …\n```\n:::\n:::\n\n\nFrom there, we realise that dengue_agg itself has duplicates. We then will use dengue_agg2 to perform the global spatial autocorrelation analysis. We'll keep dengue_agg for future use.\n\n#### 3.1 Deriving contiguity weights: Queen’s method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- dengue_agg2 %>%\n  mutate(\n    nb = st_contiguity(geometry, queen = TRUE),\n    wt = st_weights(nb, style = \"W\", allow_zero = TRUE)\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 249 features and 4 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 120.0627 ymin: 22.89401 xmax: 120.2925 ymax: 23.09144\nGeodetic CRS:  TWD97\n# A tibble: 249 × 5\n   VILLENG.x   total_cases                                  geometry nb    wt   \n * <chr>             <int>                             <POLYGON [°]> <nb>  <lis>\n 1 Andong Vil.          67 ((120.2164 23.0404, 120.2154 23.04033, 1… <int> <dbl>\n 2 Anfu Vil.           311 ((120.1932 23.0294, 120.1929 23.02938, 1… <int> <dbl>\n 3 Anhe Vil.            73 ((120.2258 23.04424, 120.2219 23.03862, … <int> <dbl>\n 4 Ankang Vil.          97 ((120.2269 23.01413, 120.2274 23.01331, … <int> <dbl>\n 5 Anqing Vil.         111 ((120.2113 23.04414, 120.2111 23.04413, … <int> <dbl>\n 6 Anshun Vil.          34 ((120.2136 23.05601, 120.2136 23.05586, … <int> <dbl>\n 7 Anxi Vil.           110 ((120.2123 23.03689, 120.212 23.03685, 1… <int> <dbl>\n 8 Bao'an Vil.          19 ((120.2304 22.93544, 120.2301 22.93511, … <int> <dbl>\n 9 Beihua Vil.          82 ((120.2034 23.00257, 120.2032 23.0022, 1… <int> <dbl>\n10 Beimen Vil.         249 ((120.2176 23.02032, 120.2173 23.02013, … <int> <dbl>\n# ℹ 239 more rows\n```\n:::\n:::\n\n\n#### 3.2 Performing Global Moran's I Test\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$total_cases,\n                  wm_q$nb,\n                  wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 12.062, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.440989474      -0.004032258       0.001361217 \n```\n:::\n:::\n\n\n#### 3.3 Performing Global Moran’s I permutation test\n\nIn R, the set.seed() function is used to set the seed for random number generation. It ensures reproducibility in simulations or any other random number-dependent operations by initializing the random number generator to a specified starting point.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$total_cases,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim=49)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 50 \n\nstatistic = 0.44099, observed rank = 50, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n:::\n:::\n\n\nSince our permutation statistics return 0.44, it signifies that there are forms of clustering present in the dataset.\n\n## 4. Local Spatial Autocorrelation Analysis\n\ncomputing lisa\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>% mutate(local_moran = local_moran(\n  total_cases, nb, wt, nsim = 79),\n  .before = 1) %>%\n  unnest(local_moran)\n```\n:::\n\n\n#### 4.1 Visualizing local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(lisa) + \n  tm_fill(\"ii\") + \n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = \"Local Moran's I of Total Cases\", \n            main.title.size = 0.8)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\n#### 4.2 Visualizing p-value of local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(lisa) +\n  tm_fill(\"p_ii_sim\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n          labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not significant\")) +\n  tm_borders(alpha = 0.5) +\n  tm_layout (main.title = \"p-value of local Moran's I\",\n             main.title.size = 0.8)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\n#### 4.3 Visualizing local Moran's I and P-value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocal_mapi <- tm_shape(lisa) + \n  tm_fill(\"ii\") + \n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = \"Local Moran's I of Total Cases\", \n            main.title.size = 0.8)\n\nlocal_mapp <- tm_shape(lisa) +\n  tm_fill(\"p_ii_sim\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n          labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not significant\")) +\n  tm_borders(alpha = 0.5) +\n  tm_layout (main.title = \"p-value of local Moran's I\",\n             main.title.size = 0.8)\n\ntmap_arrange(local_mapi, local_mapp, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\nFrom the visualizations above, we can see that there are clusters and outliers in the dataset. We can see that there are a few areas where the p-value is less than 0.05, indicating that the clusters are statistically significant. We'll then proceed to filter out the significant clusters and outliers.\n\n##### 4.4 Visualizing LISA map\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa %>% filter(p_ii <0.05)\n\ntm_shape(lisa) + \n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\n  tm_shape(lisa_sig) +\n  tm_fill(\"mean\") +\n  tm_borders(alpha=0.4)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\nOn the exterior of tainan, we notice that there are multiple Low-Low which indicates that the number of dengue cases are relatively low comapred to their neighbours. Meanwhile, in the middle of tainan, we notice that there are multiple High-High which indicates that the number of dengue cases are relatively high.\n\nFor Low-High regions, we notice that there are a few areas where the number of dengue cases are relatively low compared to their neighbours. However, they are surrounded by areas where the number of dengue cases are relatively high. This could indicate that the low number of dengue cases are outliers.\n\nSince there are still signs of clustering, we shall proceed to perform Emerging Hotspot Analysis (EHSA) to determine the location of the clusters and where the hotspots are clusters or outliers.\n\n## 5. Emerging Hotspot Analysis (EHSA)\n\nWe'll reload the dengue dataset for us to get a better look at the available data.\n\nFor EHSA, we will be using VILLCODE as a unique identifier as it is the most granular level of the dataset. However, since dengue dataset does not offer VILLCODE, we will use TOWNNAME and VILLNAME as a foreign key to join the tables.\n\n#### 5.1 Data preperation for EHSA\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue <- read_csv(\"data/aspatial/Dengue_Daily.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(dengue)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfil_dengue <- dengue %>% select(發病日, 最小統計區中心點X, 最小統計區中心點Y, 居住縣市,居住村里, 居住鄉鎮) %>% \n  rename(onset_date = 發病日, x_coordinate = 最小統計區中心點X, y_coordinate = 最小統計區中心點Y, COUNTYNAME = 居住縣市, VILLNAME = 居住村里, TOWNNAME = 居住鄉鎮)\n```\n:::\n\n\nWe need to get the epi weeks for dengues cases. We'll use [lubridate::epiweek()](https://lubridate.tidyverse.org/reference/week.html) to get the epi weeks. We use epi week to start on sunday instead of isoweek which starts on monday\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_dengue <- fil_dengue %>%\n  mutate(week = lubridate::epiweek(onset_date))\n```\n:::\n\n\nWe group by week, townname and villname to get the total cases for each week, town and village.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncases_dengue <- week_dengue %>% group_by(week, TOWNNAME, VILLNAME) %>% summarize(total_cases = n())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmerge_tnd <- left_join(tainan_vil, cases_dengue, by = c(\"TOWNNAME\", \"VILLNAME\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmerge_tnd <- merge_tnd %>% select(VILLCODE, week, total_cases)\n```\n:::\n\n\nWe'll have to form a dataframe with all the possible combinations of village codes and weeks. We'll use [expand.grid()](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/expand.grid) to create the dataframe.From there, replace missing cases with 0. This will give us a full grid to form our spacetime cube.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_villcodes <- unique(tainan_vil$VILLCODE)\nunique_weeks <- rep(31:50)\n\nall_combinations <- expand.grid(VILLCODE = unique_villcodes, week = unique_weeks)\n\n# Convert VILLCODE to character type (if it's not already)\nall_combinations$VILLCODE <- as.character(all_combinations$VILLCODE)\n\n# Merge with the original dataframe\ndf_merged <- merge(all_combinations, merge_tnd, by = c(\"VILLCODE\", \"week\"), all.x = TRUE)\n\n# Replace missing total_cases with 0\ndf_merged$total_cases[is.na(df_merged$total_cases)] <- 0\n```\n:::\n\n\nSave df_merged into rds\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(df_merged, \"data/rds/df_merged.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_merged <- readRDS(\"data/rds/df_merged.rds\")\n```\n:::\n\n\nSince spacetime cube requires the data to be in tibble format, we'll convert df_merged into tibble format. We will use as_tibble() from the tibble package to convert the dataframe into tibble format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_merged_tb <- as_tibble(df_merged)\n```\n:::\n\n\n#### 5.2 Forming our spacetime cube\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_st <- spacetime(df_merged_tb , tainan_vil,\n         .loc_col = \"VILLCODE\",.time_col = \"week\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(dengue_st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nAmazing! We managed to create a spacetime cube. We'll now proceed to perform emerging hotspot analysis on the spacetime cube.\n\n#### 5.3 Deriving spatial weight matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndg_nb <- dengue_st %>%\n  activate(\"geometry\") %>%\n  mutate(nb = include_self(st_contiguity(geometry)),\n         wt = st_inverse_distance(nb, geometry,\n                                  scale = 1,\n                                  alpha = 1),\n         .before = 1) %>%\n  set_nbs(\"nb\") %>%\n  set_wts(\"wt\")\n```\n:::\n\n\n#### 5.4 Calculating Gi\\*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngi_stars <- dg_nb %>% \n  group_by(week) %>% \n  mutate(gi_star = local_gstar_perm(\n    total_cases, nb, wt)) %>% \n  tidyr::unnest(gi_star)\n```\n:::\n\n\nSince we used Vilcode as the location, we are not able to understand which villages corresponds to which gi\\*. Therefore, let's simply plot the min and max values to get a better understanding of the data.\n\nStore gi_stars in rds\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(gi_stars, \"data/rds/gi_stars.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngi_stars <- readRDS(\"data/rds/gi_stars.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_gi <- min(gi_stars$gi_star)\nmax_gi <- max(gi_stars$gi_star)\n```\n:::\n\n\nFind the villcode where the gi_star is equals to min_gi, max_gi\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_gi_vil <- gi_stars %>% \n  filter(gi_star == min_gi) %>% \n  select(VILLCODE)\n\nmax_gi_vil <- gi_stars %>%\n  filter(gi_star == max_gi) %>%\n  select(VILLCODE)\n\nmin_gi_vil\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n# Groups:   week [1]\n   week VILLCODE   \n  <int> <chr>      \n1    41 67000350034\n```\n:::\n\n```{.r .cell-code}\nmax_gi_vil\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n# Groups:   week [1]\n   week VILLCODE   \n  <int> <chr>      \n1    34 67000350040\n```\n:::\n:::\n\n\n#### 5.5 Mann Kendall Test on Min and Max values of Gi\\*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmkt_min <- gi_stars %>% \n  ungroup() %>% \n  filter(VILLCODE == min_gi_vil$VILLCODE) |> \n  select(VILLCODE, week, gi_star)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmkt_max <- gi_stars %>% \n  ungroup() %>% \n  filter(VILLCODE == max_gi_vil$VILLCODE) |> \n  select(VILLCODE, week, gi_star)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mkt_min, \n       aes(x = week, \n           y = gi_star)) +\n  geom_line() +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-68-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mkt_max, \n       aes(x = week, \n           y = gi_star)) +\n  geom_line() +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-69-1.png){width=672}\n:::\n:::\n\n\nLet's plot them together to gauge how the min and max values defer in tainan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_line(data = mkt_min, mapping = aes(x = week, y = gi_star, color = \"Min\")) +\n  geom_line(data = mkt_max, mapping = aes(x = week, y = gi_star, color = \"Max\")) + \n  labs(x = \"Week\", y = \"GiStar Value\", \n       title = \"GiStar Min and Max Values\",\n       color = \"Villages\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-70-1.png){width=672}\n:::\n:::\n\n\nWe can see that the min and max values of gi\\* are quite different. The min value of gi\\* is relatively stable throughout the weeks while the max value of gi\\* fluctuates quite a bit. Eventually, they both converge back close to 0.\n\n#### 5.6 Performing Emerging Hotspot Analysis\n\nWe can replicate the above calculation for the entire dataset using group_by of dplyr package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nehsa <- gi_stars %>%\n  group_by(VILLCODE) %>%\n  summarise(mk = list(\n    unclass(\n      Kendall::MannKendall(gi_star)))) %>%\n  tidyr::unnest_wider(mk)\n```\n:::\n\n\nWe arrange it to show significant emerging hot/cold spots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemerging <- ehsa %>% \n  arrange(sl, abs(tau)) %>% \n  slice(1:5)\n```\n:::\n\n\nLastly, we will perform EHSA analysis by using emerging_hotspot_analysis() of sfdep package. It takes a spacetime object x (i.e. GDPPC_st), and the quoted name of the variable of interest (i.e. GDPPC) for .var argument. The k argument is used to specify the number of time lags which is set to 1 by default. Lastly, nsim map numbers of simulation to be performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nehsa <- emerging_hotspot_analysis(\n  x = dengue_st, \n  .var = \"total_cases\", \n  k = 1, \n  nsim = 99\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(ehsa, \"data/rds/ehsa.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nehsa <- readRDS(\"data/rds/ehsa.rds\")\n```\n:::\n\n\n#### 5.7 Visualising the distribution of EHSA classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ehsa,\n       aes(x = classification)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-76-1.png){width=672}\n:::\n:::\n\n\n#### 5.8 Visualising EHSA\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntn_ehsa <- tainan_vil %>%\n  left_join(ehsa,\n            by = join_by(VILLCODE == location))\n```\n:::\n\n\nTmap functions will be used to plot a categorical choropleth map by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nehsa_sig <- tn_ehsa  %>%\n  filter(p_value < 0.05)\ntmap_mode(\"plot\")\ntm_shape(tn_ehsa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(ehsa_sig) +\n  tm_fill(\"classification\") + \n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-78-1.png){width=672}\n:::\n:::\n\n\nFrom the visualisation above, we can see that there are a few areas where the p-value is less than 0.05, indicating that the clusters are statistically significant.\n\nWe'll reference the table below to understand what the classifications mean.\nSource: https://pro.arcgis.com/en/pro-app/2.8/tool-reference/space-time-pattern-mining/learnmoreemerging.htm\n\n| Pattern Name          | Definition                                                                                                                                                                                                                                                                                                     |\n|------------------|------------------------------------------------------|\n| Consecutive Cold Spot | A location with a single uninterrupted run of statistically significant cold spot bins in the final time-step intervals. The location has never been a statistically significant cold spot prior to the final cold spot run and less than ninety percent of all bins are statistically significant cold spots. |\n| Consecutive Hot Spot  | A location with a single uninterrupted run of statistically significant hot spot bins in the final time-step intervals. The location has never been a statistically significant hot spot prior to the final hot spot run and less than ninety percent of all bins are statistically significant hot spots.     |\n| New Cold Spot         | A location that is a statistically significant cold spot for the final time step and has never been a statistically significant cold spot before.                                                                                                                                                              |\n| Oscillating Cold Spot | A statistically significant cold spot for the final time-step interval that has a history of also being a statistically significant hot spot during a prior time step. Less than ninety percent of the time-step intervals have been statistically significant cold spots.                                     |\n| Oscillating Hot Spot  | A statistically significant hot spot for the final time-step interval that has a history of also being a statistically significant cold spot during a prior time step. Less than ninety percent of the time-step intervals have been statistically significant hot spots.                                      |\n| Sporadic Cold Spot    | A location that is an on-again then off-again cold spot. Less than ninety percent of the time-step intervals have been statistically significant cold spots and none of the time-step intervals have been statistically significant hot spots.                                                                 |\n| Sporadic Hot Spot     | A location that is an on-again then off-again hot spot. Less than ninety percent of the time-step intervals have been statistically significant hot spots and none of the time-step intervals have been statistically significant cold spots.                                                                  |\n| No Pattern Detected   | Does not fall into any of the hot or cold spot patterns defined below.                                                                                                                                                                                                                                         |\n\n## 6. Conclusion\n\nIn conclusion, we have successfully performed global spatial autocorrelation analysis, local spatial autocorrelation analysis and emerging hotspot analysis on the distribution of dengue fever in Tainan City, Taiwan. We have discovered that the distribution of dengue fever outbreak at Tainan City, Taiwan are spatially dependent. We have also detected clusters and outliers, and the emerging hot spot/cold spot areas.\n\nFrom the EHSA analysis, we have identified the following significant emerging hot/cold spots: Consecutive Cold Spot, Consecutive Hot Spot, New Cold Spot, Oscillating Cold Spot, Oscillating Hot Spot, Sporadic Cold Spot, Sporadic Hot Spot and No Pattern Detected. Majority of the areas are oscillating hot spots and sporadic hot spots. These suggests that the dengue fever outbreak in Tainan City, Taiwan are not consistent and are sporadic in nature. For consecutive hotspots, \n\nThe results of the analysis can be used to inform public health officials and policy makers to allocate resources and implement targeted interventions to control the spread of dengue fever in Tainan City, Taiwan.\n\n## 7. Learning points \n\nAfter Take-home exercise 2, I further realised the importance of data wrangling and data cleaning. It is important to ensure that the data is clean and in the right format before performing any analysis. Using a function is simple, but preparing a dataset for the function to use is not. I need to be more careful in the future to ensure that the data is in the right format before performing any analysis. \n\nOverall, with the QnAs from Piazza, I managed to work ma way through the exercise and understand the concepts of spatial autocorrelation and emerging hotspot analysis. I am looking forward to the next exercise to further improve my skills in spatial analysis.\n",
    "supporting": [
      "Take-home_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}