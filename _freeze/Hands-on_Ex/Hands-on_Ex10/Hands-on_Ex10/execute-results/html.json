{
  "hash": "42692df585a6636a4c5805a325369067",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 10 - Modelling Geographical Accessibility\"\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show the code\"\n\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n\ndate: \"2024-03-22\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, \n               ggstatsplot, reshape2,\n               tidyverse)\n```\n:::\n\n\nspatialacc is from the SpatialAcc package, which is a package for computing spatial accessibility measures. The package provides functions for computing the following measures:\n\n- Distance decay functions\n- Gravity models\n- Potential models\n- Kernel density estimation\n- Spatial autocorrelation\n- Spatial interpolation\n- Spatial filtering\n- Spatial smoothing\n- Spatial clustering\n\nreshape2 is a package for reshaping data frames. It provides functions for converting data between wide and long formats.\n\n\n# 1.0 Getting started \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\EbenezerHo\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex10\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `hexagons' from data source \n  `C:\\EbenezerHo\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex10\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `ELDERCARE' from data source \n  `C:\\EbenezerHo\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex10\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n:::\n:::\n\n\n## 1.1 Updating CRS \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n:::\n:::\n\n\n## 1.2 Cleaning and updating attribute fields of the geospatial data \n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\n## 1.3 Aspatial data \n\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n:::\n\nwe indicate skip = 0 to ensure that the first row is not skipped.\n\n## 1.4 tidying distance matrix \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  spread(destination_id, total_cost)%>%\n  select(c(-c('origin_id')))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n\n# 2.0 Modelling and Visualising Accessibility using Hansen Method\n\nhansen method is a gravity model that estimates the number of trips between two locations based on the distance between them. The method is based on the assumption that the number of trips between two locations is inversely proportional to the distance between them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(acc_Hansen) <- \"accHansen\"\n```\n:::\n\n\nsince the columns names look messy, we shall rename it with the above code. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- as_tibble(acc_Hansen)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 0.5, \n                            family = \"Hansen\"))\n\ncolnames(acc_Hansen) <- \"accHansen\"\nacc_Hansen <- as_tibble(acc_Hansen)\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n\n## 2.1 visualising hansen's accessibility \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapex <- st_bbox(hexagons)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n## 2.2 Statistical graphic visualisation \n\n\nFirstly, we need to add the planning region field into haxegon_Hansen simple feature data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n# 3.0 Modelling and Visualising Accessibility using KD2SFCA Method\n\nKD2SFCA is a potential model that estimates the number of trips between two locations based on the distance between them. The method is based on the assumption that the number of trips between two locations is inversely proportional to the distance between them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            d0 = 50,\n                            power = 2, \n                            family = \"KD2SFCA\"))\n\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- as_tibble(acc_KD2SFCA)\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n\n\n## 3.1 visualising KD2SFCA's accessibility \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hexagon_KD2SFCA,\n         bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: KD2SFCA method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## 3.2 Statistical graphic visualisation \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n# 4.0 Modelling and Visualising Accessibility using Spatial Accessibility Measure (SAM) Method\n\nSAM is a potential model that estimates the number of trips between two locations based on the distance between them. The method is based on the assumption that the number of trips between two locations is inversely proportional to the distance between them.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_SAM <- data.frame(ac(hexagons$demand,\n                         eldercare$capacity,\n                         distmat_km, \n                         d0 = 50,\n                         power = 2, \n                         family = \"SAM\"))\n\ncolnames(acc_SAM) <- \"accSAM\"\nacc_SAM <- as_tibble(acc_SAM)\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n```\n:::\n\n\n## 4.1 visualising SAM's accessibility \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hexagon_SAM,\n         bbox = mapex) + \n  tm_fill(col = \"accSAM\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: SAM method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 3),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n## 4.2 Statistical graphic visualisation \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, \n                       join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n# 5.0 Conclusion \n\nIn overall, this exercise was pretty interesting as we discovered different types of spatial accessibility measures. We also visualised the accessibility to eldercare facilities in Singapore using the Hansen, KD2SFCA, and SAM methods. The visualisation was done using the tmap package, which is a powerful package for creating thematic maps. \n\nWe can observe that the Hansen method produced the highest accessibility values compared to the KD2SFCA and SAM methods. This is because the Hansen method is based on the assumption that the number of trips between two locations is inversely proportional to the distance between them.\n",
    "supporting": [
      "Hands-on_Ex10_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}