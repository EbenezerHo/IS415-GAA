---
title: "Take home Exercise 01"
execute: 
  warning: false # show warnings
  eval: true # evaluate the code
  echo: true # show the code
date: "`r Sys.Date()`"
---

# Take home Exercise 1

## Application of Spatial Point Patterns Analysis to discover the geographical distribution of Grab hailing services in Singapore

## 1) Introduction

Human mobility, the movement of human beings in space and time, reflects the spatial-temporal characteristics of human behavior. With the advancement Information and Communication Technologies (ICT) especially smart phone, a large volume of data related to human mobility have been collected. By using appropriate GIS analysis methods, these data are potentially useful in supporting smart city planning and management.

In Singapore, one of the important source of data related to human mobility is from Land Transport Authority (LTA) DataMall. Two data sets related to human mobility are provided by the portal, they are: Passenger Volume by Origin Destination Train Stations and Passenger Volume by Origin Destination Bus Stops. One of the limitation of these data sets is that their location are biased to either bus stops or MRT/LRT stations. In 2020, another very interesting human mobility data set called Grab Posisi was released by GRAB, one of the largest shared taxi operator in South-east Asia. There are two data sets been released and one of them is for Singapore.

The Task

-   Using appropriate function of sf and tidyverse, preparing the following geospatial data layer in sf tibble data.frames:

    -   Grab taxi location points either by origins or destinations.![](images/clipboard-420052342.png){width="20"}

    -   Road layer within Singapore excluding outer islands. ![](images/clipboard-420052342.png){width="20"}

    -   Singapore boundary layer excluding outer islands ![](images/clipboard-420052342.png){width="20"}

-   Using the extracted data, derive traditional Kernel Density Estimation layers. ![](images/clipboard-420052342.png){width="20"}

-   Using the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE) ![](images/clipboard-420052342.png){width="20"}

-   Using appropriate tmap functions, display the kernel density layers on openstreetmap of Singapore.

-   Describe the spatial patterns revealed by the kernel density maps.

## 2) Setup and Installation of packages

```{r}
pacman:: p_load (arrow, lubridate, tidyverse, tmap, sf, raster, spatstat, tmap, maptools, sp, spNetwork)
```

## 3) Data preparation

### 3.1) Import Grab Posisi data

```{r}
#| eval: false
df <- read_parquet("data/GrabPosisi/part-00000-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
```
### 3.1.1) Convert the data type of pingtimestamp from character to date-time

Since the values seems to derive from a timestamp, we will convert the data type of pingtimestamp from character to date. This will allow us to process the data in a more efficient manner with the correct data type. We will use the as_datetime function from the lubridate package to do this.

```{r}
#| eval: false
df$pingtimestamp <- as_datetime(df$pingtimestamp)
```

### 3.1.2) extracting trip starting locations

Since GrabPosisi data is a time series data, we need to extract the first and last row of each trip id to get the origin and destination of each. We will use the dplyr package to do this.

```{r}
#| eval: false

origin_df <- df %>%  
  group_by(trj_id) %>% # group by trip id
  arrange(pingtimestamp) %>% # arrange by pingtimestamp to sort the data
  filter(row_number() == 1) %>% # get the first row of all the trip id
  mutate(weekday = wday(pingtimestamp, label = TRUE, abbr = TRUE), # get the day of the week
         start_hr = factor(hour(pingtimestamp)),# use factor to get ordinal data
         day= factor(day(pingtimestamp)))
```


### 3.1.3) Convert origin_df (aspatial) to geospatial data

In order to integrate GrabPosisi's dataset, we need to convert the origin_df and destination_df to geospatial data. We will use the st_as_sf function from the sf package to do this. We will also transform the coordinate reference system (CRS) of the data to 3414, which is the projected coordinate system for Singapore.

```{r}
#| eval: false
origin_sf <- st_as_sf(origin_df,
                      coords = c("rawlng", "rawlat"),
                      crs = 4326) %>%
  st_transform(crs = 3414)
```


### 3.2) Import Singapore Master Plan 2019 Subzone Boundary (No Sea) data

```{r}
#| eval: false
mpsz_sf <- st_read(dsn = "data", 
                layer = "MPSZ-2019")
```

### 3.2.1 Transforming the coordinate reference system (CRS) of mpsz_sf to 3414

```{r}
#| eval: false

st_crs(mpsz_sf)
```

```{r}
#| eval: false
mpsz_sf <- st_transform(mpsz_sf,3414)

```

```{r}
#| eval: false

st_crs(mpsz_sf)
```

### 3.2.2 Extracting the outer islands of mpsz and removing it from mpsz_sf

Let's first take a look at the unique values of mpsz to see if there are any outer islands in the data. We'll be using the unique function to do this.

```{r}
#| eval: false

unique(mpsz_sf$PLN_AREA_N)
```

As noted in the task, we are to exclude the outer islands from the Singapore boundary layer. We will use the st_difference function from the sf package to do this. With the above list, we can see that the outer islands are "SOUTHERN ISLANDS", "NORTH-EASTERN ISLANDS" and "WESTERN ISLANDS". We will use the st_union function to combine the outer islands and then use the st_difference function to remove the outer islands from the Singapore boundary layer.

```{r}
#| eval: false

outer_island <- mpsz_sf[mpsz_sf$PLN_AREA_N == "SOUTHERN ISLANDS" | mpsz_sf$PLN_AREA_N == "NORTH-EASTERN ISLANDS" | mpsz_sf$PLN_AREA_N == "WESTERN ISLANDS",]
```

```{r}
#| eval: false

mpsz_boundary <- st_difference(st_union(mpsz_sf),st_union(outer_island))
```

```{r}
#| eval: false

mpsz_sf_no_outer <- st_difference(mpsz_sf,st_union(outer_island))

```

```{r}
#| eval: false

plot(mpsz_sf_no_outer['PLN_AREA_N'])
```


### 3.3) Import Road data set from OpenStreetMap

```{r}
#| eval: false
roads_sf <- st_read(dsn = "data", 
                layer = "gis_osm_roads_free_1")
```

### 3.3.1) Transforming the coordinate reference system (CRS) of roads_sf to 3414

```{r}
#| eval: false

st_crs(roads_sf)
```

```{r}
#| eval: false

roads_sf_3414 <- st_transform(roads_sf,3414)
```

```{r}
#| eval: false

st_crs(roads_sf_3414)
```

### 3.3.2) Filtering roads with different conditions to make it optimal for analysis

We'll first begin by eliminating the roads with no speed limit. We will use the filter function from the dplyr package to do this. Since all roads in Singapore that are not pedestrian walkways should have a speed limit, we will filter the roads with a speed limit of greater than 0.

```{r}
#| eval: false

road = roads_sf_3414 %>%
  filter(maxspeed > 0)
```

Next, we will take a look at the unique values of fclass in roads_sf_3414 to see if there are any fclass that we need to remove. We'll be using the unique function to do this.

```{r}
#| eval: false

unique(road$fclass)
```

We can notice that there are still several fclass that we need to remove. We will remove all rows of roads that are fclass in \["primary_link" "service" "unclassified" "living_street" "footway" "secondary_link" "tertiary_link" "cycleway" "pedestrian"\].

```{r}
#| eval: false

road = road[!road$fclass %in% c("primary_link", "service", "unclassified", "living_street", "footway", "secondary_link", "tertiary_link", "cycleway", "pedestrian"),]
```

Since the data from OpenStreetMap consist of Malaysia, Brunei & Singapore, let's filter out the roads that are not in Singapore. We will use the st_intersection function from the sf package to do this.

##### Small note (for future self): Reduce datasets to only Singapore to reduce computational time. If you intially know that it consist of multiple countries, it is better to filter it out first before doing any analysis.

```{r}
#| eval: false

road = st_intersection(road, mpsz_sf_no_outer)
```


Upon inspection, we still notice that there are some roads which do not have names. Since this does not provide us with more information, let's reduce it further.

```{r}
#| eval: false

road = road[!is.na(road$name),]
```

```{r}
#| eval: false

unique(road$layer)
```

```{r}
#| eval: false

road = road[road$layer == 0,]
```

WARNING: Visualising all the roads in Singapore takes a long time. To reduce render time, an image of the results will be provided below. 

```{r}
#| eval: false

plot(road['name'])
```

![](images/sg_roads.png)


## 4) Handle invalid data

As a precaution, let's check all the main datasets for invalid data. We will use the st_is_valid function from the sf package to do this. We will then use the which function to get the indices of the invalid data and then use the length function to get the number of invalid data.

```{r}
#| eval: false
# the st_is_valid function checks whether a geometry is valid
# which returns the indices of certain values based on logical conditions
# length returns the length of data objects
length(which(st_is_valid(mpsz_sf) == FALSE))
```

```{r}
#| eval: false

length(which(st_is_valid(mpsz_sf_no_outer) == FALSE))
```

```{r}
#| eval: false

length(which(st_is_valid(mpsz_boundary) == FALSE))
```

```{r}
#| eval: false

length(which(st_is_valid(road) == FALSE))
```

```{r}
#| eval: false

length(which(st_is_valid(origin_sf) == FALSE))
```

oh no! original mpsz has 6 invalid data! lets remove it.

```{r}
#| eval: false

mpsz_sf <- st_make_valid(mpsz_sf)
```

then we'll check again

```{r}
#| eval: false

length(which(st_is_valid(mpsz_sf) == FALSE))
```
we're good to go!

### 5.1) Storing data in rds for future use

Using the write_rds function from the arrow package, we will store the data in rds format for future. This allows us to reduce the number of code chunks to run and also reduce the computational time.


```{r}
#| eval: false

write_rds(mpsz_sf_no_outer, "data/rds/mpsz.rds")
write_rds(mpsz_boundary, "data/rds/sg_sf.rds")
write_rds(road, "data/rds/roads_sf.rds")
write_rds(origin_sf, "data/rds/origin_sf.rds")
```

### 5.2) Load data from rds

```{r}
origin_sf <- read_rds("data/rds/origin_sf.rds")
sg_sf <- read_rds("data/rds/sg_sf.rds")
mpsz <- read_rds("data/rds/mpsz.rds")
roads <- read_rds("data/rds/roads_sf.rds")
```

## 6) Initialisation of Spatial Point Patterns Analysis

### 6.1) Chloropleth map of the master plan of singapore

Lets do a quick plot of a chloropleth map of the master plan of singapore to view the different towns available.

```{r}
tmap_mode("plot")
tmap_options(max.categories = 55)
tm_shape(mpsz)+
  tm_fill(col = "PLN_AREA_N")+
  tm_layout(legend.position = c("right", "bottom"),
            frame = FALSE,
            title = "Master Plan of Singapore 2019",
            legend.text.size = 0.5
            )
```
## 6.2) Grab trips in Singapore

To zoom in the different regions, we'll be plotting a chloropleth map of origin of grab trips to singapore map to determine the distribution of grab trips in singapore

```{r}
tmap_mode("view")
tm_shape(mpsz)+
  tm_polygons()+
  tm_text("PLN_AREA_N", size=0.5)+
  tm_shape(origin_sf)+
  tm_dots(alpha=0.4, size = 0.05, col = "blue")
```

Taking a look at the distribution of grab trips in singapore, we can see that the distribution is quite uniform. However, we can see that there are more grab trips in the central region of Singapore. This is expected as the central region of Singapore is the most densely populated area in Singapore.

However, I want to take a look at the different regions of Singapore to see the different distributions. I will be selecting 4 towns from different regions. 

The towns selected will be Jurong East(West), Woodlands(North), Tampines(East) and Rochor(Central).

Lets zoom in to the different regions of Singapore to see the different distributions.

## 6.3) Zooming into specific study areas

```{r}
tmp <- mpsz %>%
  filter(PLN_AREA_N == "TAMPINES")
jre <- mpsz %>%
  filter(PLN_AREA_N == "JURONG EAST")
rch <- mpsz %>%
  filter(PLN_AREA_N == "ROCHOR")
wld <- mpsz %>%
  filter(PLN_AREA_N == "WOODLANDS")
```


```{r}
road_tmp = st_intersection(roads, tmp)
road_jre= st_intersection(roads, jre)
road_rch = st_intersection(roads, rch)
road_wld = st_intersection(roads, wld)
```

```{r}
origin_tmp = st_intersection(origin_sf, tmp)
origin_jre = st_intersection(origin_sf, jre)
origin_rch = st_intersection(origin_sf, rch)
origin_wld  = st_intersection(origin_sf, wld)
```

```{r}
bound_tmp = st_union(tmp)
bound_jre = st_union(jre)
bound_rch = st_union(rch)
bound_wld = st_union(wld)
```

Let's take a look at our study area!

```{r}
tm_shape(tmp)+
  tm_polygons()+
  tm_text("SUBZONE_N", size=0.5)+
  tm_shape(origin_tmp)+
  tm_dots(alpha=0.4, size = 0.05, col = "blue")
```

```{r}
tm_shape(jre)+
  tm_polygons()+
  tm_text("SUBZONE_N", size=0.5)+
  tm_shape(origin_jre)+
  tm_dots(alpha=0.4, size = 0.05, col = "blue")
```

```{r}
tm_shape(rch)+
  tm_polygons()+
  tm_text("SUBZONE_N", size=0.5)+
  tm_shape(origin_rch)+
  tm_dots(alpha=0.4, size = 0.05, col = "blue")
```

```{r}
tm_shape(wld)+
  tm_polygons()+
  tm_text("SUBZONE_N", size=0.5)+
  tm_shape(origin_wld)+
  tm_dots(alpha=0.4, size = 0.05, col = "blue")
```

From this, we can predict how the distribution of grab trips will look like in the different regions of Singapore.

## 7) Storing data in rds and loading it from rds

Before we proceed to the next step, we shall store the data of each region into rds for future use.

```{r}
write_rds(tmp, "data/rds/tmp.rds")
write_rds(jre, "data/rds/jre.rds")
write_rds(rch, "data/rds/rch.rds")
write_rds(wld, "data/rds/wld.rds")

write_rds(road_tmp, "data/rds/road_tmp.rds")
write_rds(road_jre, "data/rds/road_jre.rds")
write_rds(road_rch, "data/rds/road_rch.rds")
write_rds(road_wld, "data/rds/road_wld.rds")

write_rds(origin_tmp, "data/rds/origin_tmp.rds")
write_rds(origin_jre, "data/rds/origin_jre.rds")
write_rds(origin_rch, "data/rds/origin_rch.rds")
write_rds(origin_wld, "data/rds/origin_wld.rds")

write_rds(bound_tmp, "data/rds/bound_tmp.rds")
write_rds(bound_jre, "data/rds/bound_jre.rds")
write_rds(bound_rch, "data/rds/bound_rch.rds")
write_rds(bound_wld, "data/rds/bound_wld.rds")
```

Load the data from rds for each region

```{r}
tmp <- read_rds("data/rds/tmp.rds")
jre <- read_rds("data/rds/jre.rds")
rch <- read_rds("data/rds/rch.rds")
wld <- read_rds("data/rds/wld.rds")

road_tmp <- read_rds("data/rds/road_tmp.rds")
road_jre <- read_rds("data/rds/road_jre.rds")
road_rch <- read_rds("data/rds/road_rch.rds")
road_wld <- read_rds("data/rds/road_wld.rds")

origin_tmp <- read_rds("data/rds/origin_tmp.rds")
origin_jre <- read_rds("data/rds/origin_jre.rds")
origin_rch <- read_rds("data/rds/origin_rch.rds")
origin_wld <- read_rds("data/rds/origin_wld.rds")

bound_tmp <- read_rds("data/rds/bound_tmp.rds")
bound_jre <- read_rds("data/rds/bound_jre.rds")
bound_rch <- read_rds("data/rds/bound_rch.rds")
bound_wld <- read_rds("data/rds/bound_wld.rds")

```


## First-order Spatial Point Patterns Analysis: Kernel Density Estimation

### 8.1) Kernel Density Estimation (KDE)

We will be getting the KDE for the 4 towns selected

### 8.1.1) Setting up the data for KDE

```{r}
bound_tmp_spc <- as(bound_tmp, "Spatial")
bound_jre_spc <- as(bound_jre, "Spatial")
bound_rch_spc <- as(bound_rch, "Spatial")
bound_wld_spc <- as(bound_wld, "Spatial")

tmp_spc <- as(tmp, "Spatial")
jre_spc <- as(jre, "Spatial")
rch_spc <- as(rch, "Spatial")
wld_spc <- as(wld, "Spatial")

origin_tmp_spc <- as(origin_tmp, "Spatial")
origin_jre_spc <- as(origin_jre, "Spatial")
origin_rch_spc <- as(origin_rch, "Spatial")
origin_wld_spc <- as(origin_wld, "Spatial")

origin_spc = as_Spatial(origin_sf)
sg = as_Spatial(sg_sf)
```

Converting spatial class into generic spatial objects

```{r}
bound_tmp_sp <- as(bound_tmp_spc, "SpatialPolygons")
bound_jre_sp <- as(bound_jre_spc, "SpatialPolygons")
bound_rch_sp <- as(bound_rch_spc, "SpatialPolygons")
bound_wld_sp <- as(bound_wld_spc, "SpatialPolygons")

sg_sp <- as(sg, "SpatialPolygons")
```

converting generic sp format into spatstat ppp format

```{r}
origin_tmp_ppp <- as(origin_tmp_spc["pingtimestamp"], "ppp")
origin_jre_ppp <- as(origin_jre_spc["pingtimestamp"], "ppp")
origin_rch_ppp <- as(origin_rch_spc["pingtimestamp"], "ppp")
origin_wld_ppp <- as(origin_wld_spc["pingtimestamp"], "ppp")

```


```{r}
origin_ppp <- as(origin_spc["pingtimestamp"], "ppp")
origin_ppp
```

### 8.1.2) Checking for duplcates

To ensure that there are no duplicated points in the origin_ppp, we will use the duplicated function from the base package to do this.

```{r}
any(duplicated(origin_ppp))
any(duplicated(origin_tmp_ppp))
any(duplicated(origin_jre_ppp))
any(duplicated(origin_rch_ppp))
any(duplicated(origin_wld_ppp))
```
Everything looks good!

```{r}
par(mfrow=c(2,2))
plot(origin_tmp_ppp, legend = FALSE)
plot(origin_jre_ppp, legend = FALSE)
plot(origin_rch_ppp, legend = FALSE)
plot(origin_wld_ppp, legend = FALSE)
```


```{r}
sg_owin <- as(sg_sp, "owin")
bound_tmp_owin <- as(bound_tmp_sp, "owin")
bound_jre_owin <- as(bound_jre_sp, "owin")
bound_rch_owin <- as(bound_rch_sp, "owin")
bound_wld_owin <- as(bound_wld_sp, "owin")
```


```{r}
plot(sg_owin)

```

```{r}
originSG_ppp = origin_ppp[sg_owin]
originTMP_ppp = origin_tmp_ppp[bound_tmp_owin]
originJRE_ppp = origin_jre_ppp[bound_jre_owin]
originRCH_ppp = origin_rch_ppp[bound_rch_owin]
originWLD_ppp = origin_wld_ppp[bound_wld_owin]
```


```{r}
par(mfrow=c(2,2))
plot(originTMP_ppp, legend = FALSE)
plot(originJRE_ppp, legend = FALSE)
plot(originRCH_ppp, legend = FALSE)
plot(originWLD_ppp, legend = FALSE)
```

```{r}
# plot origin without legend 
plot(originSG_ppp, legend = FALSE)
```

Time to calculate the density of the origin points

```{r}
kde_originSG_bw <- density(originSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
kde_originTMP_bw <- density(originTMP_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_originJRE_bw <- density(originJRE_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_originRCH_bw <- density(originRCH_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_originWLD_bw <- density(originWLD_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

```
### 8.1.3) Initial plots of the KDE graph

```{r}
plot(kde_originSG_bw)
```

```{r}
plot(kde_originTMP_bw)
```

```{r}
plot(kde_originJRE_bw)
```

```{r}
plot(kde_originRCH_bw)
```

```{r}
plot(kde_originWLD_bw)
```

### 8.1.4) Rescaling the KDE graph

We'll need to rescale into km to aid visualisation
```{r}
originSG_ppp_rescale <- rescale(originSG_ppp, 1000, "km")

originTMP_ppp_rescale <- rescale(originTMP_ppp, 1000, "km")
originJRE_ppp_rescale <- rescale(originJRE_ppp, 1000, "km")
originRCH_ppp_rescale <- rescale(originRCH_ppp, 1000, "km")
originWLD_ppp_rescale <- rescale(originWLD_ppp, 1000, "km")
```


```{r}
bw_sg <- bw.diggle(originSG_ppp)
bw_sg
bw_tmp <- bw.diggle(originTMP_ppp)
bw_tmp
bw_jre <- bw.diggle(originJRE_ppp)
bw_jre
bw_rch <- bw.diggle(originRCH_ppp)
bw_rch
bw_wld <- bw.diggle(originWLD_ppp)
bw_wld
```
### 8.1.5) Recalculating the density and replotting the KDE graph.

##### Using bw.diggle method to calculate bandwidth
```{r}
kde_originSG_bw <- density(originSG_ppp_rescale,
                            sigma=bw_sg,
                            edge=TRUE,
                            kernel="gaussian") 
plot(kde_originSG_bw)
```

```{r}
kde_originTMP_bw <- density(originTMP_ppp_rescale,
                            sigma=bw_tmp,
                            edge=TRUE,
                            kernel="gaussian")
plot(kde_originTMP_bw)
```

```{r}
kde_originJRE_bw <- density(originJRE_ppp_rescale,
                            sigma=bw_jre,
                            edge=TRUE,
                            kernel="gaussian")
plot(kde_originJRE_bw)

```

```{r}
kde_originRCH_bw <- density(originRCH_ppp_rescale,
                            sigma=bw_rch,
                            edge=TRUE,
                            kernel="gaussian")
plot(kde_originRCH_bw)
```

```{r}
kde_originWLD_bw <- density(originWLD_ppp_rescale,
                            sigma=bw_wld,
                            edge=TRUE,
                            kernel="gaussian")
plot(kde_originWLD_bw)
```


### 8.1.6) Using fixed bandwidth method

```{r}
kde_originTMP_bw <- density(originTMP_ppp_rescale,
                            sigma=0.3,
                            edge=TRUE,
                            kernel="gaussian")
plot(kde_originTMP_bw)
```

```{r}
kde_originJRE_bw <- density(originJRE_ppp_rescale,
                            sigma=0.3,
                            edge=TRUE,
                            kernel="gaussian")
plot(kde_originJRE_bw)

```

```{r}
kde_originRCH_bw <- density(originRCH_ppp_rescale,
                            sigma=0.3,
                            edge=TRUE,
                            kernel="gaussian")
plot(kde_originRCH_bw)
```

```{r}
kde_originWLD_bw <- density(originWLD_ppp_rescale,
                            sigma=0.3,
                            edge=TRUE,
                            kernel="gaussian")
plot(kde_originWLD_bw)
```

### 8.2) Insight from calculating KDE:

The kernel density estimation (KDE) is a non-parametric way to estimate the probability density function of a random variable. It is a fundamental data smoothing problem where inferences about the population are made, based on a finite data sample. In this case, we are using KDE to estimate the density of the origin points of the grab trips in the different regions of Singapore.

In the initial KDE graph, we can see that the density of the origin points in the different regions of Singapore are quite uniform. However, we can see that the density of the origin points in the central region of Singapore is higher than the other regions. This is expected as the central region of Singapore is the most densely populated area in Singapore.

However, after recalculating the KDE graph using the fixed bandwidth method, we can see that the density of the origin points in the different regions of Singapore are quite uniform. This is expected as the different regions of Singapore are quite uniform in terms of population density.


### 8.3) Converting overall KDE output into raster

```{r}
gridded_kde_originSG_bw <- as.SpatialGridDataFrame.im(kde_originSG_bw)
spplot(gridded_kde_originSG_bw)
```

Converting gridded output into raster

```{r}
raster_kde_originSG_bw <- raster(gridded_kde_originSG_bw)
```

```{r}
raster_kde_originSG_bw
```

Assigning projection systems

```{r}
projection(raster_kde_originSG_bw) <- CRS("+init=EPSG:3414")
raster_kde_originSG_bw
```

visualising the output

```{r}
tm_shape(raster_kde_originSG_bw) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

set tmap mode to plot mode

```{r}
tmap_mode("plot")
```

```{r}
tm_shape(raster_kde_originSG_bw) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```


## 9) Network Kernel Density Estimation (NKDE) for the 4 towns

```{r}
str(roads)
```

```{r}
st_crs(origin_sf)
```
### 9.1) Setting up the variables 

```{r}
road_tmp_ls = st_cast(road_tmp, "LINESTRING")
road_jre_ls = st_cast(road_jre, "LINESTRING")
road_rch_ls = st_cast(road_rch, "LINESTRING")
road_wld_ls = st_cast(road_wld, "LINESTRING")
```
The line distances is set to 200m and the minimum distance is set to 50m. This relates to the real life scenario where a person wanting to board a Grab will try to book the ride within the area. 
```{r}
lixels_tmp <- lixelize_lines(road_tmp_ls, 200, mindist = 50)
lixels_jre <- lixelize_lines(road_jre_ls, 200, mindist = 50)
lixels_rch <- lixelize_lines(road_rch_ls, 200, mindist = 50)
lixels_wld <- lixelize_lines(road_wld_ls, 200, mindist = 50)
```


```{r}
samples_tmp <- lines_center(lixels_tmp)
samples_jre <- lines_center(lixels_jre)
samples_rch <- lines_center(lixels_rch)
samples_wld <- lines_center(lixels_wld)
```
### 9.2) Getting the density

We will be using the nkde function from the spatstat package to get the density of the origin points in the different regions of Singapore.


```{r}
densities_tmp <- nkde(road_tmp_ls['name'], 
                  events = origin_tmp,
                  w = rep(1,nrow(origin_tmp)),
                  samples = samples_tmp,
                  kernel_name = "quartic",
                  bw = 200, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

```{r}
densities_jre <- nkde(road_jre_ls['name'], 
                  events = origin_jre,
                  w = rep(1,nrow(origin_jre)),
                  samples = samples_jre,
                  kernel_name = "quartic",
                  bw = 200, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

```{r}
densities_rch <- nkde(road_rch_ls['name'], 
                  events = origin_rch,
                  w = rep(1,nrow(origin_rch)),
                  samples = samples_rch,
                  kernel_name = "quartic",
                  bw = 200, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

```{r}
densities_wld <- nkde(road_wld_ls['name'], 
                  events = origin_wld,
                  w = rep(1,nrow(origin_wld)),
                  samples = samples_wld,
                  kernel_name = "quartic",
                  bw = 200, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```



```{r}
samples_tmp$density <- densities_tmp
lixels_tmp$density <- densities_tmp
samples_jre$density <- densities_jre
lixels_jre$density <- densities_jre
samples_rch$density <- densities_rch
lixels_rch$density <- densities_rch
samples_wld$density <- densities_wld
lixels_wld$density <- densities_wld
```

Similar to KDE, we'll need to rescale the density to aid visualisation

```{r}
# rescaling to help the mapping
# !!! do not run more than once. 

samples_tmp$density <- samples_tmp$density*1000
lixels_tmp$density <- lixels_tmp$density*1000
samples_jre$density <- samples_jre$density*1000
lixels_jre$density <- lixels_jre$density*1000
samples_rch$density <- samples_rch$density*1000
lixels_rch$density <- lixels_rch$density*1000
samples_wld$density <- samples_wld$density*1000
lixels_wld$density <- lixels_wld$density*1000
```
### 9.3) Visualising the density

```{r}
tm_shape(lixels_tmp)+
  tm_lines(col="density",lwd=5)+
tm_shape(origin_tmp)+
  tm_dots(alpha = 0.3)
```

```{r}
tm_shape(lixels_jre)+
  tm_lines(col="density",lwd=5)+
tm_shape(origin_jre)+
  tm_dots(alpha = 0.3)
```

```{r}
tm_shape(lixels_rch)+
  tm_lines(col="density",lwd=5)+
tm_shape(origin_rch)+
  tm_dots(alpha = 0.3)
```

```{r}
tm_shape(lixels_wld)+
  tm_lines(col="density",lwd=5)+
tm_shape(origin_wld)+
  tm_dots(alpha = 0.3)
```


### 9.4) Conclusion 

Similar to KDE, it can be seen that the density of the origin points in the different regions of Singapore are quite uniform. This is expected as the different regions of Singapore are quite uniform in terms of population density.

However, the central regions of Singapore have a higher density of origin points. This is expected as the central region of Singapore is the most densely populated area in Singapore.

For woodlands, the density is saturated in 3 major streets. Tihs can be due to the fact that woodlands is a residential area and the streets are the main roads to the residential areas. Moreover, since it's in the south of woodlands, it can mean that the area is closer to the central of Singapore. Thus, it is expected to have a higher densitiy. 

For Tampines, the density is pretty sparsed. The highest density street is towards the east of Tampines. This could be an indicative sign where most of the Grab trips are going towards the Airport or ECP or TPE.

For Jurong East, the density is pretty sparsed. The highest density street is towards the south of Jurong East. This could be an indicative sign where most of the Grab trips are going towards the north-west of Singapore. Contrary to Woodlands, it seems as if more trips are heading outwards of the central region of Singapore.  

For Rochor, the density becomes very saturated along the 3 intersections. This could be due to the fact that Rochor is a commercial area and the streets are the main roads to the commercial areas. Moreover, since it's in the central of Singapore, it is expected to have a higher density. However, if the majority of the density lies along the same vacinity, it might cause jams and traffic congestion. Therefore, it should be taken into consideration for future urban planning.
